import streamlit as st
import pandas as pd
import sys
import os
from datetime import datetime
import plotly.graph_objects as go
import plotly.express as px

# Ajouter le chemin parent pour importer utils
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from utils.data_refresher import DataRefresher

def show():
    st.title("üîÑ Rafra√Æchissement des Donn√©es")
    st.markdown("### Mettre √† jour les donn√©es DPE depuis l'API ADEME")
    st.info("üí° **Deux sources** : DPE Existants (logements anciens) + DPE Neufs (constructions neuves)")
    
    # Initialiser le refresher
    refresher = DataRefresher()
    
    # Afficher les informations actuelles
    st.markdown("---")
    
    # Afficher les colonnes communes
    with st.expander("üîç Informations sur les colonnes communes"):
        st.markdown(f"""
        **Colonnes communes identifi√©es** : {len(refresher.common_columns)}
        
        Les donn√©es proviennent de deux sources :
        - **DPE Existants** : {len(refresher.COLUMNS_EXISTANTS)} colonnes disponibles
        - **DPE Neufs** : {len(refresher.COLUMNS_NEUFS)} colonnes disponibles
        
        Pour fusionner les donn√©es, seules les colonnes communes sont conserv√©es.
        """)
        
        if st.checkbox("Voir la liste des colonnes communes"):
            cols_sorted = sorted(list(refresher.common_columns))
            st.write(f"**{len(cols_sorted)} colonnes communes :**")
            
            # Afficher en 3 colonnes
            col1, col2, col3 = st.columns(3)
            third = len(cols_sorted) // 3
            
            with col1:
                for col in cols_sorted[:third]:
                    st.caption(f"‚Ä¢ {col}")
            with col2:
                for col in cols_sorted[third:2*third]:
                    st.caption(f"‚Ä¢ {col}")
            with col3:
                for col in cols_sorted[2*third:]:
                    st.caption(f"‚Ä¢ {col}")
    
    st.markdown("---")
    st.markdown("#### üìä √âtat actuel des donn√©es")
    
    col1, col2, col3, col4 = st.columns(4)
    
    last_update = refresher.get_last_update_date()
    
    with col1:
        if os.path.exists(refresher.DATA_FILE):
            df = pd.read_csv(refresher.DATA_FILE)
            st.metric("üìÅ Total DPE", f"{len(df):,}")
        else:
            st.metric("üìÅ Total DPE", "0")
    
    with col2:
        # Afficher le nombre de DPE existants si la colonne source_dpe existe
        if os.path.exists(refresher.DATA_FILE):
            df = pd.read_csv(refresher.DATA_FILE)
            if 'source_dpe' in df.columns:
                existants = len(df[df['source_dpe'] == 'existant'])
                st.metric("üè† DPE Existants", f"{existants:,}")
            else:
                st.metric("üè† DPE Existants", "N/A")
        else:
            st.metric("üè† DPE Existants", "0")
    
    with col3:
        # Afficher le nombre de DPE neufs si la colonne source_dpe existe
        if os.path.exists(refresher.DATA_FILE):
            df = pd.read_csv(refresher.DATA_FILE)
            if 'source_dpe' in df.columns:
                neufs = len(df[df['source_dpe'] == 'neuf'])
                st.metric("üèóÔ∏è DPE Neufs", f"{neufs:,}")
            else:
                st.metric("üèóÔ∏è DPE Neufs", "N/A")
        else:
            st.metric("üèóÔ∏è DPE Neufs", "0")
    
    with col4:
        if last_update:
            st.metric("üìÖ Derni√®re m√†j", last_update)
        else:
            st.metric("üìÖ Derni√®re m√†j", "Jamais")
    
    st.markdown("---")
    
    # Options de rafra√Æchissement
    st.markdown("#### ‚öôÔ∏è Options de rafra√Æchissement")
    
    col1, col2 = st.columns(2)
    
    with col1:
        refresh_mode = st.radio(
            "Mode de rafra√Æchissement",
            options=["Nouveaux DPE uniquement", "Tout recharger"],
            help="Choisir entre mettre √† jour uniquement les nouveaux DPE ou tout recharger"
        )
    
    with col2:
        create_backup = st.checkbox(
            "Cr√©er une sauvegarde",
            value=True,
            help="Cr√©er une sauvegarde des donn√©es actuelles avant la mise √† jour"
        )
    
    st.markdown("---")
    
    # Bouton de rafra√Æchissement
    if st.button("üöÄ Lancer le rafra√Æchissement", type="primary", width='stretch'):
        
        # Placeholder pour les messages de progression
        progress_bar = st.progress(0)
        status_text = st.empty()
        detail_text = st.empty()
        
        try:
            if refresh_mode == "Nouveaux DPE uniquement":
                # Mode incr√©mental
                status_text.info("üîç Recherche de nouveaux DPE (existants + neufs)...")
                
                current_source = {"value": ""}
                
                def update_progress(current, total, code_postal, source):
                    current_source["value"] = source
                    progress = current / total
                    progress_bar.progress(progress)
                    
                    emoji = "üè†" if source == "existants" else "üèóÔ∏è"
                    status_text.info(f"{emoji} R√©cup√©ration DPE {source}...")
                    detail_text.caption(f"Code postal : {code_postal} ({current}/{total})")
                
                new_df, stats = refresher.refresh_new_data(progress_callback=update_progress)
                
                if stats['total_count'] == 0:
                    status_text.success("‚úÖ Aucun nouveau DPE trouv√©. Les donn√©es sont √† jour !")
                    st.balloons()
                else:
                    status_text.info(f"üîÑ Fusion de {stats['total_count']} nouveaux DPE avec les donn√©es existantes...")
                    
                    # Fusionner avec les donn√©es existantes
                    merged_df = refresher.merge_with_existing(new_df)
                    
                    # Sauvegarder
                    refresher.save_refreshed_data(merged_df, backup=create_backup)
                    
                    # Mettre √† jour les m√©tadonn√©es
                    refresher.save_metadata(
                        datetime.now().strftime("%Y-%m-%d"),
                        len(merged_df),
                        stats['existants_count'],
                        stats['neufs_count']
                    )
                    
                    progress_bar.progress(1.0)
                    status_text.success(f"‚úÖ Rafra√Æchissement termin√© !")
                    detail_text.empty()
                    
                    # Afficher les statistiques d√©taill√©es
                    st.markdown("---")
                    st.markdown("#### üìà Statistiques du rafra√Æchissement")
                    
                    col1, col2, col3, col4 = st.columns(4)
                    
                    with col1:
                        st.metric("üÜï Nouveaux DPE", f"{stats['total_count']:,}")
                    
                    with col2:
                        st.metric("üè† Existants", f"{stats['existants_count']:,}", 
                                delta=f"+{stats['existants_count']}")
                    
                    with col3:
                        st.metric("üèóÔ∏è Neufs", f"{stats['neufs_count']:,}",
                                delta=f"+{stats['neufs_count']}")
                    
                    with col4:
                        st.metric("üìä Total apr√®s m√†j", f"{len(merged_df):,}")
                    
                    # Graphique de r√©partition
                    if 'source_dpe' in new_df.columns:
                        st.markdown("#### üìä R√©partition des nouveaux DPE")
                        
                        fig = go.Figure(data=[
                            go.Pie(
                                labels=['Existants', 'Neufs'],
                                values=[stats['existants_count'], stats['neufs_count']],
                                marker=dict(colors=['#4CAF50', '#2196F3']),
                                hole=0.4
                            )
                        ])
                        
                        fig.update_layout(
                            title="R√©partition des nouveaux DPE par source",
                            height=350
                        )
                        
                        st.plotly_chart(fig, width='stretch')
                    
                    # Aper√ßu des nouvelles donn√©es
                    st.markdown("#### üëÄ Aper√ßu des nouvelles donn√©es")
                    
                    # Onglets pour s√©parer existants et neufs
                    if 'source_dpe' in new_df.columns:
                        tab1, tab2 = st.tabs(["üè† DPE Existants", "üèóÔ∏è DPE Neufs"])
                        
                        with tab1:
                            existants_df = new_df[new_df['source_dpe'] == 'existant']
                            if len(existants_df) > 0:
                                st.dataframe(existants_df.head(10), width='stretch')
                            else:
                                st.info("Aucun nouveau DPE existant")
                        
                        with tab2:
                            neufs_df = new_df[new_df['source_dpe'] == 'neuf']
                            if len(neufs_df) > 0:
                                st.dataframe(neufs_df.head(10), width='stretch')
                            else:
                                st.info("Aucun nouveau DPE neuf")
                    else:
                        st.dataframe(new_df.head(10), width='stretch')
                    
                    st.balloons()
            
            else:
                # Mode complet : recharger toutes les donn√©es
                status_text.warning("‚ö†Ô∏è Mode rechargement complet activ√©. Cela peut prendre plusieurs minutes...")
                
                def update_progress(current, total, code_postal):
                    progress = current / total
                    progress_bar.progress(progress)
                    status_text.info(f"üì° T√©l√©chargement complet... {code_postal} ({current}/{total})")
                
                # Utiliser la logique de fetch_data_smart pour tout recharger
                all_results = []
                total_codes = len(refresher.codes_postaux)
                
                for idx, cp in enumerate(refresher.codes_postaux):
                    update_progress(idx + 1, total_codes, cp)
                    results = refresher.fetch_data_smart(cp)
                    all_results.extend(results)
                
                if not all_results:
                    status_text.error("‚ùå Aucune donn√©e r√©cup√©r√©e")
                else:
                    status_text.info("üíæ Sauvegarde des donn√©es...")
                    
                    df_complete = pd.DataFrame(all_results)
                    refresher.save_refreshed_data(df_complete, backup=create_backup)
                    refresher.save_metadata(datetime.now().strftime("%Y-%m-%d"), len(df_complete))
                    
                    progress_bar.progress(1.0)
                    status_text.success(f"‚úÖ Rechargement complet termin√© ! {len(df_complete):,} DPE r√©cup√©r√©s.")
                    
                    st.balloons()
        
        except Exception as e:
            status_text.error(f"‚ùå Erreur lors du rafra√Æchissement : {e}")
            st.exception(e)
    
    # Section d'information
    st.markdown("---")
    st.markdown("#### ‚ÑπÔ∏è Informations")
    
    with st.expander("üìñ Comment fonctionne le rafra√Æchissement ?"):
        st.markdown("""
        **Mode "Nouveaux DPE uniquement"** :
        - R√©cup√®re uniquement les DPE enregistr√©s depuis la derni√®re mise √† jour
        - Plus rapide et √©conome en ressources
        - Recommand√© pour les mises √† jour r√©guli√®res
        
        **Mode "Tout recharger"** :
        - R√©cup√®re toutes les donn√©es depuis l'API ADEME
        - Plus long mais garantit des donn√©es compl√®tes
        - Recommand√© en cas de probl√®me ou pour une r√©initialisation
        
        **Gestion des doublons** :
        - Les doublons sont automatiquement supprim√©s bas√©s sur le num√©ro de DPE
        - En cas de doublon, la version la plus r√©cente est conserv√©e
        
        **Sauvegarde** :
        - Une sauvegarde horodat√©e est cr√©√©e avant chaque mise √† jour si l'option est activ√©e
        - Format : `donnees_ademe_finales_nettoyees_69_final_pret.csv.backup_YYYYMMDD_HHMMSS`
        """)
    
    with st.expander("üîß Configuration des codes postaux"):
        st.markdown(f"""
        **Fichier de configuration** : `{refresher.codes_postaux_file}`
        
        **Codes postaux configur√©s** : {len(refresher.codes_postaux)}
        """)
        
        # Afficher quelques codes postaux
        if len(refresher.codes_postaux) > 0:
            st.write("Exemples de codes postaux :")
            st.code(", ".join(refresher.codes_postaux[:10]) + ("..." if len(refresher.codes_postaux) > 10 else ""))

if __name__ == "__main__":
    show()